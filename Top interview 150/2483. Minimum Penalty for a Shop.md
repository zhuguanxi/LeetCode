# 2483. Minimum Penalty for a Shop

## Problem Link
[Problem](https://leetcode.com/problems/minimum-penalty-for-a-shop/description/?envType=daily-question&envId=2025-12-26)

## Problem Description
You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y':

* if the ith character is 'Y', it means that customers come at the ith hour
* whereas 'N' indicates that no customers come at the ith hour.
If the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows:

* For every hour when the shop is open and no customers come, the penalty increases by 1.
* For every hour when the shop is closed and customers come, the penalty increases by 1.
Return the earliest hour at which the shop must be closed to incur a minimum penalty.

Note that if a shop closes at the jth hour, it means the shop is closed at the hour j.

### WAY 1:
* Time Complexity O(n*n), n : customers.size()
```
class Solution {
public:
    int bestClosingTime(string customers) {
        const int INF = 1e9;  
        
        int earily = 0;
        int min_pen = INF;     

        for (int i=0; i<=customers.size(); i++)
        {
            int penalty = 0;
            for (int j=0; j<customers.size(); j++)
            {
                if (i<=j && customers[j]=='Y')
                    penalty++;
                else if (i>j && customers[j]=='N')
                    penalty++;
            }
            if (penalty < min_pen)
            {
                min_pen = penalty;
                earily = i;
            }
        }
        return earily;
    }
};
```
### WAY 2
* Time Complexity O(3n) = O(n), n : customers.size(), Space Complexity O(2n) = O(n)
* 主要想法是第i小時左邊有多少'N' + 第i小時(含)右邊有多少'Y' = 總共的penalty
```
class Solution {
public:
    int bestClosingTime(string customers) {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);

        vector<int> left_penalty(customers.size()+1, 0);
        vector<int> right_penalty(customers.size()+1, 0);
        const int INF = 1e9;

        for (int i=1; i<=customers.size(); i++)
        {
            if (customers[i-1] == 'N')
                left_penalty[i] = left_penalty[i-1] + 1;
            else
                left_penalty[i] = left_penalty[i-1];
        }  
        
        for (int j=customers.size()-1; j>=0; j--)
        {
            if (customers[j] == 'Y')
                right_penalty[j] = right_penalty[j+1] + 1;
            else
                right_penalty[j] = right_penalty[j+1];
        }  

        int earily = 0;
        int local_min_pen = INF;
        for (int i=0; i<customers.size()+1; i++)
        {
            if (local_min_pen > (left_penalty[i]+right_penalty[i]))
            {
                local_min_pen =  (left_penalty[i]+right_penalty[i]);
                earily = i;
            }
        }
        return earily;
    }
};
```
### WAY 3:
* Time Complexity O(n), n : customers.size()
* $$
cost(c) =
\begin{cases}
-1, & \text{if } c = \text{'Y'} \\
+1, & \text{if } c = \text{'N'}
\end{cases}
$$

```
class Solution {
public:
    int bestClosingTime(string customers) {
        int bestTime = 0;
        int minPenalty = 0;
        int prefix = 0;
        
        for (int i = 0; i < customers.length(); i++) {
            prefix += customers[i] == 'Y' ? -1 : 1;
            
            if (prefix < minPenalty) {
                bestTime = i + 1;
                minPenalty = prefix;
            }
        }
        
        return bestTime;
    }
};
```