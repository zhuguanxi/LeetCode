# 756. Pyramid Transition Matrix

## Problem Link
[Problem](https://leetcode.com/problems/pyramid-transition-matrix/description/?envType=daily-question&envId=2025-12-29)

## Problem Description
You are stacking blocks to form a pyramid. Each block has a color, which is represented by a single letter. Each row of blocks contains one less block than the row beneath it and is centered on top.

To make the pyramid aesthetically pleasing, there are only specific triangular patterns that are allowed. A triangular pattern consists of a single block stacked on top of two blocks. The patterns are given as a list of three-letter strings allowed, where the first two characters of a pattern represent the left and right bottom blocks respectively, and the third character is the top block.

* For example, "ABC" represents a triangular pattern with a 'C' block stacked on top of an 'A' (left) and 'B' (right) block. Note that this is different from "BAC" where 'B' is on the left bottom and 'A' is on the right bottom.
You start with a bottom row of blocks bottom, given as a single string, that you must use as the base of the pyramid.

Given bottom and allowed, return true if you can build the pyramid all the way to the top such that every triangular pattern in the pyramid is in allowed, or false otherwise.

## 解題思路
是一個 Backtracking (回溯法) / DFS 的問題
* Hint 1: 原本的 allowed List 給的是字串 "ABC"，這在搜尋時很難查。可以先建立一個 Look-up Table：Key:存(左下積木, 右下積木)Value:存List<可行的上方積木>，這樣就能用 $O(1)$ 時間查出積木上面可以放什麼
* Hint 2: 一層一層蓋上去，Current State是目前這一層的字串(例如 "ABCD"）。Next State:是下一層的字串(長度會是下層 len - 1，例如 "XYZ"）。當目前字串長度為1時，表示蓋到塔頂了
* Hint 3: 使用雙重遞迴，最難的地方在於對於同一對基底(Left, Right)，可能有多個合法的 Top。必須嘗試所有可能的下一層，只要其中一種能成功蓋到頂端即可。

### WAY 1:
```
class Solution {
    unordered_map<string, vector<char>> allowed_map;
    unordered_set<string> failed;
public:
    bool solve(string row, string next_row, int index)
    {
        if (row.size() == 1)
            return true;

        if (row.size()-1 == next_row.size())
        {
            if (failed.count(next_row)) return false;
            if (solve(next_row, "", 0)) {
                return true;
            }

            failed.insert(next_row);
            return false;
        }
            
        string key = {row[index], row[index+1]}; 
        
        if (allowed_map.find(key) == allowed_map.end())
            return false;

        for (char top : allowed_map[key]) {
            if (solve(row, next_row + top, index + 1)) {
                return true;
            }
        }
        return false;
    }

    bool pyramidTransition(string bottom, vector<string>& allowed) {
        for (int i=0; i<allowed.size(); i++)
        {
            string keys = allowed[i].substr(0, 2);
            allowed_map[keys].push_back(allowed[i][2]);
        }
        return solve(bottom, "", 0);
    }
};
```
* C：允許的積木種類數量(題目限制 7, 'A'-'G')
* N：底部字串 bottom 的長度(題目限制 8)
* Time Complexity $O(C^{N^2})$