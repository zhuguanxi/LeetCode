# 840. Magic Squares In Grid

## Problem Link
[Problem](https://leetcode.com/problems/magic-squares-in-grid/description/?envType=daily-question&envId=2025-12-30)

## Problem Description
A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.

Given a row x col grid of integers, how many 3 x 3 magic square subgrids are there?

Note: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.


### WAY 1:
```
class Solution {
public:
    bool check_row_sum(vector<vector<int>>& grid, int row, int col, bool check)
    {
        vector<int> cnt(10, 0);
        for (int i=row; i<=(row+2); i++)
        {
            int row_sum = 0;
            for (int k=col; k<=(col+2); k++)
            {
                int val = grid[i][k];
                if (val > 9 || val < 1 || cnt[val] > 0)
                    return false;
                cnt[val]++;
                row_sum += val;
            }  
            if (row_sum != 15 || !check)
                return false;
        }
        return true;
    }

    bool check_col_sum(vector<vector<int>>& grid, int row, int col, bool check)
    {
        vector<int> cnt(10, 0);
        for (int i=col; i<=(col+2); i++)
        {
            int col_sum = 0;
            for (int k=row; k<=(row+2); k++)
            {
                int val = grid[k][i];
                if ( val > 9 || val < 1 || cnt[val] > 0 )
                    return false;
                cnt[val]++;
                col_sum += val;
            }  
            if (col_sum != 15 || !check)
                return false;
        }
        return true;
    }

    int numMagicSquaresInside(vector<vector<int>>& grid) {
        int magic_cnt = 0;

        if (grid[0].size() < 3 || grid.size() < 3)
            return magic_cnt;
        
        for (int i=0, l=0; i<grid[0].size()-2 && l<grid.size()-2; i++)
        {
            bool check_row = true;
            bool check_col = true;

            check_row = check_row_sum(grid, l, i, check_row);
            check_col = check_col_sum(grid, l, i, check_row);

            if ((grid[l][i] + grid[l+1][i+1] + grid[l+2][i+2]) == 15 && (grid[l+2][i] + grid[l+1][i+1] + grid[l][i+2]) == 15 && check_row && check_col)
                magic_cnt ++;
            if (i == grid[0].size()-3 && (l+1)<grid.size()-2 )
            {
                i = -1;
                l++;
            }
        }
        return magic_cnt;
    }
};
```
* R列 C行
* 總共要檢查 $(R-2) \times (C-2)$ 個區塊，每次要計算9個格子
* Time Complexity $O(9RC) = O(RC)$
* 這種範圍鎖定的使用 vector 或是 array 都比 set 來的更快

### WAY 2:
```
class Solution {
public:
    bool isMagic(vector<vector<int>>& grid, int row, int col) {
        // 先檢查 1-9 數字是否合法
        vector<int> count(10, 0); 
        for (int i = row; i < row + 3; i++) {
            for (int j = col; j < col + 3; j++) {
                int val = grid[i][j];
                if (val < 1 || val > 9 || count[val] > 0) return false;
                count[val]++;
            }
        }

        // 檢查 row sum
        for (int i = row; i < row + 3; i++) {
            int sum = 0;
            for (int j = col; j < col + 3; j++) {
                sum += grid[i][j];
            }
            if (sum != 15) return false;
        }

        // 3. 檢查 col sum
        for (int j = col; j < col + 3; j++) {
            int sum = 0;
            for (int i = row; i < row + 3; i++) {
                sum += grid[i][j];
            }
            if (sum != 15) return false;
        }

        // 檢查對角線
        int diag1 = grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2];
        int diag2 = grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col];
        
        if (diag1 != 15 || diag2 != 15) return false;

        return true;
    }

    int numMagicSquaresInside(vector<vector<int>>& grid) {
        int rows = grid.size();
        int cols = grid[0].size();
        int magic_cnt = 0;

        if (rows < 3 || cols < 3) return 0;

        for (int i = 0; i <= rows - 3; i++) {
            for (int j = 0; j <= cols - 3; j++) {
                if (isMagic(grid, i, j)) {
                    magic_cnt++;
                }
            }
        }
        
        return magic_cnt;
    }
};
```