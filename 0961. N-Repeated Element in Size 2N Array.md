# 961. N-Repeated Element in Size 2N Array

## Problem Link
[Problem](https://leetcode.com/problems/n-repeated-element-in-size-2n-array/description/?envType=daily-question&envId=2026-01-02)

## Problem Description
You are given an integer array nums with the following properties:

* nums.length == 2 * n.
* nums contains n + 1 unique elements.
* Exactly one element of nums is repeated n times.
Return the element that is repeated n times.

### WAY 1:
```
class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
        cout.tie(0);

        int N = nums.size() / 2;

        unordered_map<int, int> num_table;

        for (int i=0; i<nums.size(); i++)
        {
            num_table[nums[i]]++;
            if (num_table[nums[i]] == N)
                return nums[i];
        }
        return 0;
    }
};
```
* N：nums 的長度(2 <= N <= 5000)
* Time Complexity $O(N)$
* Space Complexity $O(N-1) = O(N)$

### WAY 2:
```
class Solution {
public:
    int repeatedNTimes(vector<int>& nums) {
        for (int i = 0; i < nums.size() - 2; ++i)
            if (nums[i] == nums[i + 1] || nums[i] == nums[i + 2])
                return nums[i];
        return nums.back();
    }
};
```
* 因為此陣列包含 2n 個元素，其中一個元素重複出現 n 次，其餘元素各出現一次。這意味著重複出現的元素恰好佔據了陣列的一半。所以只需要檢查第 i 個元素和第 (i+1) (i+2)個是否一樣
* 因為只掃過 $length−2$ 個，而最後一個元素並不會被掃到，像 [2, 1, 3, 2]，因此他一定是重複的元素
* Time Complexity $O(N)$
* Space Complexity $O(1)$